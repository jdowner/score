<!DOCTYPE html>
<html>
  <head>
    <title>drum-music-app</title>
  </head>
  <script src="raphael-v2.1.2-min.js"></script>
  <script src="underscore-v1.5.2-min.js"></script>
  <script src="vexflow-min.js"></script>
  <body>
    <svg id="score" width="800" height="1000"></svg>
  </body>
  <script>
    var Renderer = function(id) {
      canvas = document.getElementById(id)
      this.renderer = new Vex.Flow.Renderer(canvas, Vex.Flow.Renderer.Backends.RAPHAEL)
      this.ctx = this.renderer.getContext()
    }

    Renderer.prototype.clear = function() {
      this.ctx.clear()
    }

    Renderer.prototype.draw_stave = function(x, y, width, in_stave, options) {
      // Create new vexflow stave object
      var stave = new Vex.Flow.Stave(x, y, width);

      var options = options || {}
      var clef = options.clef || null
      var signature = options.signature || null
      var end_bar = options.end_bar || null

      // Add a clef if this stave has one
      if(clef) {
        stave.addClef(clef)
      }

      // Add a time signature if there is one
      if(signature) {
        stave.addTimeSignature(signature)
      }

      if(end_bar) {
        stave.setEndBarType(end_bar)
      }

      stave.setContext(this.ctx)
      stave.draw()

      // Create a voice
      var voice = new Vex.Flow.Voice({
        num_beats: 4,
        beat_value: 4,
        resolution: Vex.Flow.RESOLUTION
      });

      // Add notes to the voice
      voice.addTickables(in_stave.notes);

      // Format and justify the notes
      var formatter = new Vex.Flow.Formatter()
      formatter.joinVoices([voice])
      formatter.format([voice], width)
      formatter.formatToStave([voice], stave)

      // Draw the voice
      voice.draw(this.ctx, stave);
    }

    Renderer.prototype.draw_score = function(score) {
      var measures_per_line = Math.floor(this.ctx.paper.width / score.measure_width)
      this.draw_stave(0, 0, score.measure_width, score.staves[0],
        {"clef":"percussion", "signature":"4/4"})
      for(var k = 1; k < score.staves.length - 1; k++) {
        var x = score.measure_width * (k % measures_per_line)
        var y = score.measure_height * Math.floor(k / measures_per_line)
        this.draw_stave(x, y, score.measure_width, score.staves[k])
      }
      var k = score.staves.length - 1
      var x = score.measure_width * (k % measures_per_line)
      var y = score.measure_height * Math.floor(k / measures_per_line)
      this.draw_stave(x, y, score.measure_width, score.staves[k],
        {"end_bar":Vex.Flow.Barline.type.END})
    }

    function make_note(name) {
      return new Vex.Flow.StaveNote({ keys: ["c/5"], duration: name})
    }

    function make_notes(str) {
      var notes = new Array()
      var str_notes = str.split(" ")
      for(var i = 0; i < str_notes.length; i++) {
        notes.push(this.make_note(str_notes[i]))
      }
      return notes
    }

    var Stave = function(notes) {
      this.notes = make_notes(notes)
    }

    Stave.prototype.notes = function() {
      return this.notes
    }

    var Score = function() {
      this.clef = "percussion"
      this.signature = "4/4"
      this.measure_height = 100
      this.measure_width = 300

      this.staves = new Array()
      this.staves.push(new Stave('8 8r 8 4 16 16 8 8'))
      this.staves.push(new Stave('8 16r 16 8 4 16 16 8 8'))
      this.staves.push(new Stave('4 4 4 4'))
      this.staves.push(new Stave('8 8r 8 4 16 16 8 8'))
      this.staves.push(new Stave('8 16r 16 8 4 16 16 8 8'))
      this.staves.push(new Stave('4 4 4 4'))
      this.staves.push(new Stave('8 8r 8 4 16 16 8 8'))
      this.staves.push(new Stave('8 16r 16 8 4 16 16 8 8'))
      this.staves.push(new Stave('4 4 4 4'))
    }

    Score.prototype.clef = function() {
      return this.clef
    }

    Score.prototype.signature = function() {
      return this.signature
    }

    Score.prototype.shuffle = function() {
      this.staves = _.shuffle(this.staves)
    }

    var score = new Score()
    var renderer = new Renderer("score")

    function update() {
      renderer.clear()
      renderer.draw_score(score)
    }

    function order() {
    }

    function init() {
      update()

      var svg = document.getElementById("score")
      svg.addEventListener('click', function(e) {
        score.shuffle()
        update()
      })
    }

    window.addEventListener('load', init, false)
  </script>
</html>
